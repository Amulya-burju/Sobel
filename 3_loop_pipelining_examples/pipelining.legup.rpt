//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 4.0 (http://legup.org)
// Compiled: Sun Jul 26 12:56:54 2015
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Fri Apr 26 09:38:59 2019
//----------------------------------------------------------------------------//

Found Loop: Loop at depth 1 containing: %.preheader.i<header><latch><exiting>

Label: loop
Trip count: 262144
Induction variable:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ]
Found a loop carried dependency:
Distance: 1
Type: Same address
Store to ram: prev_prev_row at GEP: %9 I:   store i8 %8, i8* %9, align 1, !tbaa !2
Load to ram: prev_prev_row at GEP: %9 I:   %10 = load i8* %9, align 1, !tbaa !2
Found a loop carried dependency:
Distance: 1
Type: Same address
Store to ram: prev_row at GEP: %7 I:   store i8 %6, i8* %7, align 1, !tbaa !2
Load to ram: prev_row at GEP: %7 I:   %8 = load i8* %7, align 1, !tbaa !2
distance 1 from:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ] to   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
distance 1 from:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ] to   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
distance 1 from:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ] to   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
distance 1 from:   %6 = load i8* %5, align 1, !tbaa !2 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
distance 1 from:   %8 = load i8* %7, align 1, !tbaa !2 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
distance 1 from:   %10 = load i8* %9, align 1, !tbaa !2 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Loop preheader: 
--------------------------------------------------------------------------------

Calculating resource MII using IMS technique
Constraints from FuName: elaine_512_input_local_mem_dual_port Issue Slots: 2
-  %6 = load i8* %5, align 1, !tbaa !2
resMII (due to elaine_512_input_local_mem_dual_port): 1
Constraints from FuName: output_image_local_mem_dual_port Issue Slots: 2
-  store i8 %59, i8* %60, align 1, !tbaa !2
resMII (due to output_image_local_mem_dual_port): 1
Constraints from FuName: prev_prev_row_local_mem_dual_port Issue Slots: 2
-  %10 = load i8* %9, align 1, !tbaa !2
-  store i8 %8, i8* %9, align 1, !tbaa !2
resMII (due to prev_prev_row_local_mem_dual_port): 1
Constraints from FuName: prev_row_local_mem_dual_port Issue Slots: 2
-  %8 = load i8* %7, align 1, !tbaa !2
-  store i8 %6, i8* %7, align 1, !tbaa !2
resMII (due to prev_row_local_mem_dual_port): 1
Overall resMII: 1
largestPossibleII: 98
resMII: 1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Finding all Loop Recurrences
Found 13 elementary recurrence cycles
Recurrence 1:
delay: 1 I:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
delay: 1 I:   %12 = add nsw i32 %prev_prev_row_index.0, 1
delay: 1 I:   %15 = icmp eq i32 %12, 512
delay: 1 I:   %16 = select i1 %15, i32 0, i32 %12
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 2:
delay: 1 I:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
delay: 1 I:   %12 = add nsw i32 %prev_prev_row_index.0, 1
delay: 1 I:   %16 = select i1 %15, i32 0, i32 %12
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 3:
delay: 1 I:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
delay: 1 I:   %11 = add nsw i32 %prev_row_index.0, 1
delay: 1 I:   %13 = icmp eq i32 %11, 512
delay: 1 I:   %14 = select i1 %13, i32 0, i32 %11
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 4:
delay: 1 I:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
delay: 1 I:   %11 = add nsw i32 %prev_row_index.0, 1
delay: 1 I:   %14 = select i1 %13, i32 0, i32 %11
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 5:
delay: 1 I:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
delay: 1 I:   %1 = icmp eq i32 %x.013.i, 511
delay: 1 I:   %..i = select i1 %1, i32 0, i32 %4
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 6:
delay: 1 I:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
delay: 1 I:   %4 = add nsw i32 %x.013.i, 1
delay: 1 I:   %..i = select i1 %1, i32 0, i32 %4
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 7:
delay: 1 I:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
delay: 1 I:   %3 = add nsw i32 %2, %y.012.i
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 8:
delay: 1 I:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
delay: 1 I:   %22 = icmp ne i32 %start.011.i, 0
delay: 1 I:   %47 = select i1 %22, i32 %start.011.i, i32 %46
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 9:
delay: 1 I:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
delay: 1 I:   %47 = select i1 %22, i32 %start.011.i, i32 %46
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 10:
delay: 1 I:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
delay: 1 I:   %21 = select i1 %19, i32 1, i32 %y_offset.010.i
delay: 1 I:   %64 = add nsw i32 %63, %21
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 11:
delay: 1 I:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
delay: 1 I:   %20 = select i1 %19, i32 1, i32 %x_offset.09.i
delay: 1 I:   %61 = add nsw i32 %20, 1
delay: 1 I:   %62 = icmp eq i32 %61, 511
delay: 1 I:   %65 = select i1 %62, i32 -1, i32 %61
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 12:
delay: 1 I:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
delay: 1 I:   %20 = select i1 %19, i32 1, i32 %x_offset.09.i
delay: 1 I:   %61 = add nsw i32 %20, 1
delay: 1 I:   %65 = select i1 %62, i32 -1, i32 %61
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 13:
delay: 1 I:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
delay: 1 I:   %66 = add nsw i32 %i.08.i, 1
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Overall recMII (max of recMII from all elementary recurrence cycles): 1
--------------------------------------------------------------------------------
Calculating recurrence MII using SDC scheduler
Trying recMII (SDC) = 1
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ] to   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
	j:   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
distance 1 from:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ] to   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
	j:   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
distance 1 from:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ] to   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
	j:   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %3 = add nsw i32 %2, %y.012.i
	j:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %..i = select i1 %1, i32 0, i32 %4
	j:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
distance 1 from:   %6 = load i8* %5, align 1, !tbaa !2 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %6 = load i8* %5, align 1, !tbaa !2
	j:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
distance 1 from:   %8 = load i8* %7, align 1, !tbaa !2 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %8 = load i8* %7, align 1, !tbaa !2
	j:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
distance 1 from:   %10 = load i8* %9, align 1, !tbaa !2 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %10 = load i8* %9, align 1, !tbaa !2
	j:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %14 = select i1 %13, i32 0, i32 %11
	j:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %16 = select i1 %15, i32 0, i32 %12
	j:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %47 = select i1 %22, i32 %start.011.i, i32 %46
	j:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %64 = add nsw i32 %63, %21
	j:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %65 = select i1 %62, i32 -1, i32 %61
	j:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %66 = add nsw i32 %i.08.i, 1
	j:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
recMII = 1 using SDC scheduler
--------------------------------------------------------------------------------
Initial II = 1
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ] to   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
	j:   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
distance 1 from:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ] to   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
	j:   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
distance 1 from:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ] to   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
	j:   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %3 = add nsw i32 %2, %y.012.i
	j:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %..i = select i1 %1, i32 0, i32 %4
	j:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
distance 1 from:   %6 = load i8* %5, align 1, !tbaa !2 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %6 = load i8* %5, align 1, !tbaa !2
	j:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
distance 1 from:   %8 = load i8* %7, align 1, !tbaa !2 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %8 = load i8* %7, align 1, !tbaa !2
	j:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
distance 1 from:   %10 = load i8* %9, align 1, !tbaa !2 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %10 = load i8* %9, align 1, !tbaa !2
	j:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %14 = select i1 %13, i32 0, i32 %11
	j:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %16 = select i1 %15, i32 0, i32 %12
	j:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %47 = select i1 %22, i32 %start.011.i, i32 %46
	j:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %64 = add nsw i32 %63, %21
	j:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %65 = select i1 %62, i32 -1, i32 %61
	j:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %66 = add nsw i32 %i.08.i, 1
	j:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Computing Heights
No children (height=0):   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str1, i32 0, i32 0)) #2
No children (height=0):   store i8 %59, i8* %60, align 1, !tbaa !2
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
No children (height=0):   store i8 %6, i8* %7, align 1, !tbaa !2
distance 1 from:   %6 = load i8* %5, align 1, !tbaa !2 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
No children (height=0):   store i8 %8, i8* %9, align 1, !tbaa !2
distance 1 from:   %8 = load i8* %7, align 1, !tbaa !2 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
distance 1 from:   %10 = load i8* %9, align 1, !tbaa !2 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
No children (height=0):   br i1 %exitcond5, label %sobel_fast_pipelined.exit, label %.preheader.i
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
--------------------------------------------------------------------------------
Height: 0:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Height: 0:   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Height: 0:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Height: 0:   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Height: 0:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Height: 0:   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Height: 0:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Height: 0:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Height: 0:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Height: 0:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Height: 0:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Height: 0:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Height: 0:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Height: 0:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Height: 0:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str1, i32 0, i32 0)) #2
Height: 1:   %1 = icmp eq i32 %x.013.i, 511
Height: 1:   %2 = zext i1 %1 to i32
Height: 1:   %3 = add nsw i32 %2, %y.012.i
Height: 1:   %4 = add nsw i32 %x.013.i, 1
Height: 1:   %..i = select i1 %1, i32 0, i32 %4
Height: 1:   %5 = getelementptr inbounds [512 x [512 x i8]]* @elaine_512_input, i32 0, i32 %3, i32 %..i
Height: 1:   %6 = load i8* %5, align 1, !tbaa !2
Height: 1:   %7 = getelementptr inbounds [512 x i8]* @prev_row, i32 0, i32 %prev_row_index.0
Height: 1:   %8 = load i8* %7, align 1, !tbaa !2
Height: 1:   %9 = getelementptr inbounds [512 x i8]* @prev_prev_row, i32 0, i32 %prev_prev_row_index.0
Height: 1:   %10 = load i8* %9, align 1, !tbaa !2
Height: 0:   store i8 %8, i8* %9, align 1, !tbaa !2
Height: 0:   store i8 %6, i8* %7, align 1, !tbaa !2
Height: 0:   %11 = add nsw i32 %prev_row_index.0, 1
Height: 0:   %12 = add nsw i32 %prev_prev_row_index.0, 1
Height: 0:   %13 = icmp eq i32 %11, 512
Height: 0:   %14 = select i1 %13, i32 0, i32 %11
Height: 0:   %15 = icmp eq i32 %12, 512
Height: 0:   %16 = select i1 %15, i32 0, i32 %12
Height: 0:   %17 = icmp eq i32 %3, 2
Height: 0:   %18 = icmp eq i32 %..i, 2
Height: 0:   %19 = and i1 %17, %18
Height: 0:   %20 = select i1 %19, i32 1, i32 %x_offset.09.i
Height: 0:   %21 = select i1 %19, i32 1, i32 %y_offset.010.i
Height: 0:   %22 = icmp ne i32 %start.011.i, 0
Height: 0:   %y.off.i.i = add i32 %21, -1
Height: 0:   %phitmp.i.i = icmp sgt i32 %20, 510
Height: 0:   %notlhs.i.i = icmp ugt i32 %y.off.i.i, 509
Height: 0:   %notrhs.i.i = icmp slt i32 %20, 1
Height: 0:   %not.or.cond3.i.i = or i1 %notrhs.i.i, %notlhs.i.i
Height: 0:   %phitmp..i.i = or i1 %phitmp.i.i, %not.or.cond3.i.i
Height: 0:   %23 = zext i1 %phitmp..i.i to i32
Height: 0:   %24 = zext i8 %window.0.1.0 to i32
Height: 0:   %25 = zext i8 %window.0.2.0 to i32
Height: 0:   %26 = mul nsw i32 %25, -2
Height: 0:   %27 = sub i32 %26, %24
Height: 0:   %28 = zext i8 %10 to i32
Height: 0:   %29 = sub i32 %27, %28
Height: 0:   %30 = sub i32 %24, %28
Height: 0:   %31 = zext i8 %window.1.1.0 to i32
Height: 0:   %32 = shl nuw nsw i32 %31, 1
Height: 0:   %33 = add nsw i32 %32, %30
Height: 0:   %34 = zext i8 %8 to i32
Height: 0:   %35 = mul nsw i32 %34, -2
Height: 0:   %36 = add nsw i32 %35, %33
Height: 0:   %37 = zext i8 %window.2.1.0 to i32
Height: 0:   %38 = add nsw i32 %37, %29
Height: 0:   %39 = add nsw i32 %37, %36
Height: 0:   %40 = zext i8 %window.2.2.0 to i32
Height: 0:   %41 = shl nuw nsw i32 %40, 1
Height: 0:   %42 = add nsw i32 %41, %38
Height: 0:   %43 = zext i8 %6 to i32
Height: 0:   %44 = add nsw i32 %43, %42
Height: 0:   %45 = sub i32 %39, %43
Height: 0:   %46 = zext i1 %19 to i32
Height: 0:   %47 = select i1 %22, i32 %start.011.i, i32 %46
Height: 0:   %48 = icmp eq i32 %47, 0
Height: 0:   %49 = icmp sgt i32 %44, 255
Height: 0:   %50 = select i1 %49, i32 255, i32 %44
Height: 0:   %51 = icmp slt i32 %50, 0
Height: 0:   %52 = icmp sgt i32 %45, 255
Height: 0:   %53 = select i1 %52, i32 255, i32 %45
Height: 0:   %54 = icmp slt i32 %53, 0
Height: 0:   %.op.i = sub i32 0, %50
Height: 0:   %..i1.neg.i = select i1 %51, i32 0, i32 %.op.i
Height: 0:   %.op14.op.i = sub i32 255, %53
Height: 0:   %.neg.i = select i1 %54, i32 255, i32 %.op14.op.i
Height: 0:   %55 = add i32 %.neg.i, %..i1.neg.i
Height: 0:   %56 = sext i1 %48 to i32
Height: 0:   %57 = icmp ne i32 %23, %56
Height: 0:   %58 = trunc i32 %55 to i8
Height: 0:   %59 = select i1 %57, i8 0, i8 %58
Height: 0:   %60 = getelementptr inbounds [512 x [512 x i8]]* @output_image, i32 0, i32 %21, i32 %20
Height: 0:   store i8 %59, i8* %60, align 1, !tbaa !2
Height: 0:   %61 = add nsw i32 %20, 1
Height: 0:   %62 = icmp eq i32 %61, 511
Height: 0:   %63 = zext i1 %62 to i32
Height: 0:   %64 = add nsw i32 %63, %21
Height: 0:   %65 = select i1 %62, i32 -1, i32 %61
Height: 0:   %66 = add nsw i32 %i.08.i, 1
Height: 0:   %exitcond5 = icmp eq i32 %66, 262144
Height: 0:   br i1 %exitcond5, label %sobel_fast_pipelined.exit, label %.preheader.i
Modulo Scheduler Type: SDC_BACKTRACKING
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ] to   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
	j:   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
distance 1 from:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ] to   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
	j:   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
distance 1 from:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ] to   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
	j:   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
distance 1 from:   %3 = add nsw i32 %2, %y.012.i to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %3 = add nsw i32 %2, %y.012.i
	j:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
distance 1 from:   %..i = select i1 %1, i32 0, i32 %4 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %..i = select i1 %1, i32 0, i32 %4
	j:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
distance 1 from:   %6 = load i8* %5, align 1, !tbaa !2 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %6 = load i8* %5, align 1, !tbaa !2
	j:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
distance 1 from:   %8 = load i8* %7, align 1, !tbaa !2 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %8 = load i8* %7, align 1, !tbaa !2
	j:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
distance 1 from:   %10 = load i8* %9, align 1, !tbaa !2 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %10 = load i8* %9, align 1, !tbaa !2
	j:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
distance 1 from:   %14 = select i1 %13, i32 0, i32 %11 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %14 = select i1 %13, i32 0, i32 %11
	j:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
distance 1 from:   %16 = select i1 %15, i32 0, i32 %12 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %16 = select i1 %15, i32 0, i32 %12
	j:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
distance 1 from:   %47 = select i1 %22, i32 %start.011.i, i32 %46 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %47 = select i1 %22, i32 %start.011.i, i32 %46
	j:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
distance 1 from:   %64 = add nsw i32 %63, %21 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %64 = add nsw i32 %63, %21
	j:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
distance 1 from:   %65 = select i1 %62, i32 -1, i32 %61 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %65 = select i1 %62, i32 -1, i32 %61
	j:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
distance 1 from:   %66 = add nsw i32 %i.08.i, 1 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %66 = add nsw i32 %i.08.i, 1
	j:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
Skipping timing constraint due to loop recurrence on this path
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Finding initial ASAP schedule
Time: 0 I:   %8 = load i8* %7, align 1, !tbaa !2
Time: 0 I:   %10 = load i8* %9, align 1, !tbaa !2
Time: 1 I:   %6 = load i8* %5, align 1, !tbaa !2
Time: 1 I:   store i8 %8, i8* %9, align 1, !tbaa !2
Time: 2 I:   store i8 %6, i8* %7, align 1, !tbaa !2
Time: 4 I:   store i8 %59, i8* %60, align 1, !tbaa !2
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Calculating perturbation priority function
Constraining >= 2.00:   %6 = load i8* %5, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 21 for:   %6 = load i8* %5, align 1, !tbaa !2
Constraining >= 1.00:   %8 = load i8* %7, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 17 for:   %8 = load i8* %7, align 1, !tbaa !2
Constraining >= 1.00:   %10 = load i8* %9, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 30 for:   %10 = load i8* %9, align 1, !tbaa !2
Constraining >= 3.00:   store i8 %8, i8* %9, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 1 for:   store i8 %8, i8* %9, align 1, !tbaa !2
Constraining >= 3.00:   store i8 %6, i8* %7, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 1 for:   store i8 %6, i8* %7, align 1, !tbaa !2
Constraining >= 5.00:   store i8 %59, i8* %60, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 1 for:   store i8 %59, i8* %60, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Control Step: 0
Scheduling:   %10 = load i8* %9, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 0?
No resource conflict: found available issue slot
Can we schedule instruction at time: 0 ignoring resource constraints?
Constraining == 0.00:   %10 = load i8* %9, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 0 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 0.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 0):   %10 = load i8* %9, align 1, !tbaa !2
TimeSlot: 0 Scheduling:   %10 = load i8* %9, align 1, !tbaa !2
Constraining == 0.00:   %10 = load i8* %9, align 1, !tbaa !2
Control Step: 0
Scheduling:   %8 = load i8* %7, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 0?
No resource conflict: found available issue slot
Can we schedule instruction at time: 0 ignoring resource constraints?
Constraining == 0.00:   %8 = load i8* %7, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 0 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 0.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 0):   %8 = load i8* %7, align 1, !tbaa !2
TimeSlot: 0 Scheduling:   %8 = load i8* %7, align 1, !tbaa !2
Constraining == 0.00:   %8 = load i8* %7, align 1, !tbaa !2
Control Step: 1
Scheduling:   %6 = load i8* %5, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 1?
No resource conflict: found available issue slot
Can we schedule instruction at time: 1 ignoring resource constraints?
Constraining == 1.00:   %6 = load i8* %5, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 1 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 1.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 1):   %6 = load i8* %5, align 1, !tbaa !2
TimeSlot: 1 Scheduling:   %6 = load i8* %5, align 1, !tbaa !2
Constraining == 1.00:   %6 = load i8* %5, align 1, !tbaa !2
Control Step: 1
Scheduling:   store i8 %8, i8* %9, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 1?
No resource conflict: found available issue slot
Can we schedule instruction at time: 1 ignoring resource constraints?
Constraining == 1.00:   store i8 %8, i8* %9, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 1 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 1.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 1):   store i8 %8, i8* %9, align 1, !tbaa !2
TimeSlot: 1 Scheduling:   store i8 %8, i8* %9, align 1, !tbaa !2
Constraining == 1.00:   store i8 %8, i8* %9, align 1, !tbaa !2
Control Step: 2
Scheduling:   store i8 %6, i8* %7, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 2?
No resource conflict: found available issue slot
Can we schedule instruction at time: 2 ignoring resource constraints?
Constraining == 2.00:   store i8 %6, i8* %7, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 2 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 2.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 2):   store i8 %6, i8* %7, align 1, !tbaa !2
TimeSlot: 2 Scheduling:   store i8 %6, i8* %7, align 1, !tbaa !2
Constraining == 2.00:   store i8 %6, i8* %7, align 1, !tbaa !2
Control Step: 4
Scheduling:   store i8 %59, i8* %60, align 1, !tbaa !2
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 4?
No resource conflict: found available issue slot
Can we schedule instruction at time: 4 ignoring resource constraints?
Constraining == 4.00:   store i8 %59, i8* %60, align 1, !tbaa !2
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 4 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 4.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 4):   store i8 %59, i8* %60, align 1, !tbaa !2
TimeSlot: 4 Scheduling:   store i8 %59, i8* %60, align 1, !tbaa !2
Constraining == 4.00:   store i8 %59, i8* %60, align 1, !tbaa !2
Assigning timeslot: 0 to   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Assigning timeslot: 0 to   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Assigning timeslot: 0 to   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Assigning timeslot: 0 to   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Assigning timeslot: 0 to   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Assigning timeslot: 0 to   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Assigning timeslot: 0 to   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !1
Assigning timeslot: 0 to   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str1, i32 0, i32 0)) #2
Assigning timeslot: 0 to   %1 = icmp eq i32 %x.013.i, 511
Assigning timeslot: 0 to   %2 = zext i1 %1 to i32
Assigning timeslot: 0 to   %3 = add nsw i32 %2, %y.012.i
Assigning timeslot: 0 to   %4 = add nsw i32 %x.013.i, 1
Assigning timeslot: 0 to   %..i = select i1 %1, i32 0, i32 %4
Assigning timeslot: 1 to   %5 = getelementptr inbounds [512 x [512 x i8]]* @elaine_512_input, i32 0, i32 %3, i32 %..i
Assigning timeslot: 0 to   %7 = getelementptr inbounds [512 x i8]* @prev_row, i32 0, i32 %prev_row_index.0
Assigning timeslot: 1 to   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Assigning timeslot: 0 to   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Assigning timeslot: 0 to   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Assigning timeslot: 0 to   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Assigning timeslot: 0 to   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Assigning timeslot: 0 to   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Assigning timeslot: 0 to   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Assigning timeslot: 0 to   %46 = zext i1 %19 to i32
Assigning timeslot: 0 to   %9 = getelementptr inbounds [512 x i8]* @prev_prev_row, i32 0, i32 %prev_prev_row_index.0
Assigning timeslot: 0 to   %11 = add nsw i32 %prev_row_index.0, 1
Assigning timeslot: 0 to   %12 = add nsw i32 %prev_prev_row_index.0, 1
Assigning timeslot: 0 to   %13 = icmp eq i32 %11, 512
Assigning timeslot: 0 to   %14 = select i1 %13, i32 0, i32 %11
Assigning timeslot: 0 to   %15 = icmp eq i32 %12, 512
Assigning timeslot: 0 to   %16 = select i1 %15, i32 0, i32 %12
Assigning timeslot: 0 to   %17 = icmp eq i32 %3, 2
Assigning timeslot: 0 to   %18 = icmp eq i32 %..i, 2
Assigning timeslot: 0 to   %19 = and i1 %17, %18
Assigning timeslot: 0 to   %20 = select i1 %19, i32 1, i32 %x_offset.09.i
Assigning timeslot: 0 to   %21 = select i1 %19, i32 1, i32 %y_offset.010.i
Assigning timeslot: 0 to   %22 = icmp ne i32 %start.011.i, 0
Assigning timeslot: 1 to   %y.off.i.i = add i32 %21, -1
Assigning timeslot: 1 to   %phitmp.i.i = icmp sgt i32 %20, 510
Assigning timeslot: 1 to   %notlhs.i.i = icmp ugt i32 %y.off.i.i, 509
Assigning timeslot: 1 to   %notrhs.i.i = icmp slt i32 %20, 1
Assigning timeslot: 1 to   %not.or.cond3.i.i = or i1 %notrhs.i.i, %notlhs.i.i
Assigning timeslot: 1 to   %phitmp..i.i = or i1 %phitmp.i.i, %not.or.cond3.i.i
Assigning timeslot: 1 to   %23 = zext i1 %phitmp..i.i to i32
Assigning timeslot: 0 to   %24 = zext i8 %window.0.1.0 to i32
Assigning timeslot: 0 to   %25 = zext i8 %window.0.2.0 to i32
Assigning timeslot: 0 to   %26 = mul nsw i32 %25, -2
Assigning timeslot: 0 to   %27 = sub i32 %26, %24
Assigning timeslot: 1 to   %28 = zext i8 %10 to i32
Assigning timeslot: 1 to   %29 = sub i32 %27, %28
Assigning timeslot: 1 to   %30 = sub i32 %24, %28
Assigning timeslot: 0 to   %31 = zext i8 %window.1.1.0 to i32
Assigning timeslot: 0 to   %32 = shl nuw nsw i32 %31, 1
Assigning timeslot: 1 to   %33 = add nsw i32 %32, %30
Assigning timeslot: 1 to   %34 = zext i8 %8 to i32
Assigning timeslot: 1 to   %35 = mul nsw i32 %34, -2
Assigning timeslot: 1 to   %36 = add nsw i32 %35, %33
Assigning timeslot: 0 to   %37 = zext i8 %window.2.1.0 to i32
Assigning timeslot: 1 to   %38 = add nsw i32 %37, %29
Assigning timeslot: 2 to   %39 = add nsw i32 %37, %36
Assigning timeslot: 1 to   %40 = zext i8 %window.2.2.0 to i32
Assigning timeslot: 1 to   %41 = shl nuw nsw i32 %40, 1
Assigning timeslot: 1 to   %42 = add nsw i32 %41, %38
Assigning timeslot: 2 to   %43 = zext i8 %6 to i32
Assigning timeslot: 2 to   %44 = add nsw i32 %43, %42
Assigning timeslot: 2 to   %45 = sub i32 %39, %43
Assigning timeslot: 0 to   %47 = select i1 %22, i32 %start.011.i, i32 %46
Assigning timeslot: 1 to   %48 = icmp eq i32 %47, 0
Assigning timeslot: 2 to   %49 = icmp sgt i32 %44, 255
Assigning timeslot: 2 to   %50 = select i1 %49, i32 255, i32 %44
Assigning timeslot: 3 to   %51 = icmp slt i32 %50, 0
Assigning timeslot: 2 to   %52 = icmp sgt i32 %45, 255
Assigning timeslot: 3 to   %53 = select i1 %52, i32 255, i32 %45
Assigning timeslot: 3 to   %54 = icmp slt i32 %53, 0
Assigning timeslot: 3 to   %.op.i = sub i32 0, %50
Assigning timeslot: 3 to   %..i1.neg.i = select i1 %51, i32 0, i32 %.op.i
Assigning timeslot: 3 to   %.op14.op.i = sub i32 255, %53
Assigning timeslot: 4 to   %.neg.i = select i1 %54, i32 255, i32 %.op14.op.i
Assigning timeslot: 4 to   %55 = add i32 %.neg.i, %..i1.neg.i
Assigning timeslot: 1 to   %56 = sext i1 %48 to i32
Assigning timeslot: 1 to   %57 = icmp ne i32 %23, %56
Assigning timeslot: 4 to   %58 = trunc i32 %55 to i8
Assigning timeslot: 4 to   %59 = select i1 %57, i8 0, i8 %58
Assigning timeslot: 1 to   %60 = getelementptr inbounds [512 x [512 x i8]]* @output_image, i32 0, i32 %21, i32 %20
Assigning timeslot: 0 to   %61 = add nsw i32 %20, 1
Assigning timeslot: 1 to   %62 = icmp eq i32 %61, 511
Assigning timeslot: 1 to   %63 = zext i1 %62 to i32
Assigning timeslot: 1 to   %64 = add nsw i32 %63, %21
Assigning timeslot: 1 to   %65 = select i1 %62, i32 -1, i32 %61
Assigning timeslot: 0 to   %66 = add nsw i32 %i.08.i, 1
Assigning timeslot: 0 to   br i1 %exitcond5, label %sobel_fast_pipelined.exit, label %.preheader.i
Assigning timeslot: 0 to   %exitcond5 = icmp eq i32 %66, 262144
Scheduled.
MII = 1
II = 1
Final Modulo Reservation Table:
FuName: elaine_512_input_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   %6 = load i8* %5, align 1, !tbaa !3
   issue slot: 1 instr: printing a <null> value
FuName: output_image_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   store i8 %59, i8* %60, align 1, !tbaa !3
   issue slot: 1 instr: printing a <null> value
FuName: prev_prev_row_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   %10 = load i8* %9, align 1, !tbaa !3
   issue slot: 1 instr:   store i8 %8, i8* %9, align 1, !tbaa !3
FuName: prev_row_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   %8 = load i8* %7, align 1, !tbaa !3
   issue slot: 1 instr:   store i8 %6, i8* %7, align 1, !tbaa !3

Final Pipeline Schedule:
Total pipeline stages: 5
Stage: 0
Time: 0 Stage: 0 instr:   %window.2.1.0 = phi i8 [ 0, %0 ], [ %window.2.2.0, %.preheader.i ]
Time: 0 Stage: 0 instr:   %window.1.2.0 = phi i8 [ 0, %0 ], [ %8, %.preheader.i ]
Time: 0 Stage: 0 instr:   %window.1.1.0 = phi i8 [ 0, %0 ], [ %window.1.2.0, %.preheader.i ]
Time: 0 Stage: 0 instr:   %window.0.2.0 = phi i8 [ 0, %0 ], [ %10, %.preheader.i ]
Time: 0 Stage: 0 instr:   %window.0.1.0 = phi i8 [ 0, %0 ], [ %window.0.2.0, %.preheader.i ]
Time: 0 Stage: 0 instr:   %prev_prev_row_index.0 = phi i32 [ 0, %0 ], [ %16, %.preheader.i ]
Time: 0 Stage: 0 instr:   %prev_row_index.0 = phi i32 [ 0, %0 ], [ %14, %.preheader.i ]
Time: 0 Stage: 0 instr:   %x.013.i = phi i32 [ -1, %0 ], [ %..i, %.preheader.i ]
Time: 0 Stage: 0 instr:   %y.012.i = phi i32 [ 0, %0 ], [ %3, %.preheader.i ]
Time: 0 Stage: 0 instr:   %start.011.i = phi i32 [ 0, %0 ], [ %47, %.preheader.i ]
Time: 0 Stage: 0 instr:   %y_offset.010.i = phi i32 [ -1, %0 ], [ %64, %.preheader.i ]
Time: 0 Stage: 0 instr:   %x_offset.09.i = phi i32 [ -1, %0 ], [ %65, %.preheader.i ]
Time: 0 Stage: 0 instr:   %i.08.i = phi i32 [ 0, %0 ], [ %66, %.preheader.i ], !legup.canonical_induction !2
Time: 0 Stage: 0 instr:   tail call void @__legup_label(i8* getelementptr inbounds ([5 x i8]* @.str1, i32 0, i32 0)) #2
Time: 0 Stage: 0 instr:   %1 = icmp eq i32 %x.013.i, 511
Time: 0 Stage: 0 instr:   %2 = zext i1 %1 to i32
Time: 0 Stage: 0 instr:   %3 = add nsw i32 %2, %y.012.i
Time: 0 Stage: 0 instr:   %4 = add nsw i32 %x.013.i, 1
Time: 0 Stage: 0 instr:   %..i = select i1 %1, i32 0, i32 %4
Time: 0 Stage: 0 instr:   %7 = getelementptr inbounds [512 x i8]* @prev_row, i32 0, i32 %prev_row_index.0
Time: 0 Stage: 0 instr:   %8 = load i8* %7, align 1, !tbaa !3
Time: 0 Stage: 0 instr:   %9 = getelementptr inbounds [512 x i8]* @prev_prev_row, i32 0, i32 %prev_prev_row_index.0
Time: 0 Stage: 0 instr:   %10 = load i8* %9, align 1, !tbaa !3
Time: 0 Stage: 0 instr:   %11 = add nsw i32 %prev_row_index.0, 1
Time: 0 Stage: 0 instr:   %12 = add nsw i32 %prev_prev_row_index.0, 1
Time: 0 Stage: 0 instr:   %13 = icmp eq i32 %11, 512
Time: 0 Stage: 0 instr:   %14 = select i1 %13, i32 0, i32 %11
Time: 0 Stage: 0 instr:   %15 = icmp eq i32 %12, 512
Time: 0 Stage: 0 instr:   %16 = select i1 %15, i32 0, i32 %12
Time: 0 Stage: 0 instr:   %17 = icmp eq i32 %3, 2
Time: 0 Stage: 0 instr:   %18 = icmp eq i32 %..i, 2
Time: 0 Stage: 0 instr:   %19 = and i1 %17, %18
Time: 0 Stage: 0 instr:   %20 = select i1 %19, i32 1, i32 %x_offset.09.i
Time: 0 Stage: 0 instr:   %21 = select i1 %19, i32 1, i32 %y_offset.010.i
Time: 0 Stage: 0 instr:   %22 = icmp ne i32 %start.011.i, 0
Time: 0 Stage: 0 instr:   %24 = zext i8 %window.0.1.0 to i32
Time: 0 Stage: 0 instr:   %25 = zext i8 %window.0.2.0 to i32
Time: 0 Stage: 0 instr:   %26 = mul nsw i32 %25, -2
Time: 0 Stage: 0 instr:   %27 = sub i32 %26, %24
Time: 0 Stage: 0 instr:   %31 = zext i8 %window.1.1.0 to i32
Time: 0 Stage: 0 instr:   %32 = shl nuw nsw i32 %31, 1
Time: 0 Stage: 0 instr:   %37 = zext i8 %window.2.1.0 to i32
Time: 0 Stage: 0 instr:   %46 = zext i1 %19 to i32
Time: 0 Stage: 0 instr:   %47 = select i1 %22, i32 %start.011.i, i32 %46
Time: 0 Stage: 0 instr:   %61 = add nsw i32 %20, 1
Time: 0 Stage: 0 instr:   %66 = add nsw i32 %i.08.i, 1
Time: 0 Stage: 0 instr:   %exitcond5 = icmp eq i32 %66, 262144
Time: 0 Stage: 0 instr:   br i1 %exitcond5, label %sobel_fast_pipelined.exit, label %.preheader.i
Stage: 1
Time: 1 Stage: 1 instr:   %window.2.2.0 = phi i8 [ 0, %0 ], [ %6, %.preheader.i ]
Time: 1 Stage: 1 instr:   %5 = getelementptr inbounds [512 x [512 x i8]]* @elaine_512_input, i32 0, i32 %3, i32 %..i
Time: 1 Stage: 1 instr:   %6 = load i8* %5, align 1, !tbaa !3
Time: 1 Stage: 1 instr:   store i8 %8, i8* %9, align 1, !tbaa !3
Time: 1 Stage: 1 instr:   %y.off.i.i = add i32 %21, -1
Time: 1 Stage: 1 instr:   %phitmp.i.i = icmp sgt i32 %20, 510
Time: 1 Stage: 1 instr:   %notlhs.i.i = icmp ugt i32 %y.off.i.i, 509
Time: 1 Stage: 1 instr:   %notrhs.i.i = icmp slt i32 %20, 1
Time: 1 Stage: 1 instr:   %not.or.cond3.i.i = or i1 %notrhs.i.i, %notlhs.i.i
Time: 1 Stage: 1 instr:   %phitmp..i.i = or i1 %phitmp.i.i, %not.or.cond3.i.i
Time: 1 Stage: 1 instr:   %23 = zext i1 %phitmp..i.i to i32
Time: 1 Stage: 1 instr:   %28 = zext i8 %10 to i32
Time: 1 Stage: 1 instr:   %29 = sub i32 %27, %28
Time: 1 Stage: 1 instr:   %30 = sub i32 %24, %28
Time: 1 Stage: 1 instr:   %33 = add nsw i32 %32, %30
Time: 1 Stage: 1 instr:   %34 = zext i8 %8 to i32
Time: 1 Stage: 1 instr:   %35 = mul nsw i32 %34, -2
Time: 1 Stage: 1 instr:   %36 = add nsw i32 %35, %33
Time: 1 Stage: 1 instr:   %38 = add nsw i32 %37, %29
Time: 1 Stage: 1 instr:   %40 = zext i8 %window.2.2.0 to i32
Time: 1 Stage: 1 instr:   %41 = shl nuw nsw i32 %40, 1
Time: 1 Stage: 1 instr:   %42 = add nsw i32 %41, %38
Time: 1 Stage: 1 instr:   %48 = icmp eq i32 %47, 0
Time: 1 Stage: 1 instr:   %56 = sext i1 %48 to i32
Time: 1 Stage: 1 instr:   %57 = icmp ne i32 %23, %56
Time: 1 Stage: 1 instr:   %60 = getelementptr inbounds [512 x [512 x i8]]* @output_image, i32 0, i32 %21, i32 %20
Time: 1 Stage: 1 instr:   %62 = icmp eq i32 %61, 511
Time: 1 Stage: 1 instr:   %63 = zext i1 %62 to i32
Time: 1 Stage: 1 instr:   %64 = add nsw i32 %63, %21
Time: 1 Stage: 1 instr:   %65 = select i1 %62, i32 -1, i32 %61
Stage: 2
Time: 2 Stage: 2 instr:   store i8 %6, i8* %7, align 1, !tbaa !3
Time: 2 Stage: 2 instr:   %39 = add nsw i32 %37, %36
Time: 2 Stage: 2 instr:   %43 = zext i8 %6 to i32
Time: 2 Stage: 2 instr:   %44 = add nsw i32 %43, %42
Time: 2 Stage: 2 instr:   %45 = sub i32 %39, %43
Time: 2 Stage: 2 instr:   %49 = icmp sgt i32 %44, 255
Time: 2 Stage: 2 instr:   %50 = select i1 %49, i32 255, i32 %44
Time: 2 Stage: 2 instr:   %52 = icmp sgt i32 %45, 255
Stage: 3
Time: 3 Stage: 3 instr:   %51 = icmp slt i32 %50, 0
Time: 3 Stage: 3 instr:   %53 = select i1 %52, i32 255, i32 %45
Time: 3 Stage: 3 instr:   %54 = icmp slt i32 %53, 0
Time: 3 Stage: 3 instr:   %.op.i = sub i32 0, %50
Time: 3 Stage: 3 instr:   %..i1.neg.i = select i1 %51, i32 0, i32 %.op.i
Time: 3 Stage: 3 instr:   %.op14.op.i = sub i32 255, %53
Stage: 4
Time: 4 Stage: 4 instr:   %.neg.i = select i1 %54, i32 255, i32 %.op14.op.i
Time: 4 Stage: 4 instr:   %55 = add i32 %.neg.i, %..i1.neg.i
Time: 4 Stage: 4 instr:   %58 = trunc i32 %55 to i8
Time: 4 Stage: 4 instr:   %59 = select i1 %57, i8 0, i8 %58
Time: 4 Stage: 4 instr:   store i8 %59, i8* %60, align 1, !tbaa !3


Pipeline Table:
Total pipeline stages: 5
Stage:        0              1              2              3              4
   II:        0     |        0     |        0     |        0     |        0
 Time:        0     |        1     |        2     |        3     |        4
              -%window.2.2....%window.2.2....%window.2.2....%window.2.2....
%window.2.1....%window.2.1....%window.2.1....%window.2.1....%window.2.1....
%window.1.2....%window.1.2....%window.1.2....%window.1.2....%window.1.2....
%window.1.1....%window.1.1....%window.1.1....%window.1.1....%window.1.1....
%window.0.2....%window.0.2....%window.0.2....%window.0.2....%window.0.2....
%window.0.1....%window.0.1....%window.0.1....%window.0.1....%window.0.1....
%prev_prev_r...%prev_prev_r...%prev_prev_r...%prev_prev_r...%prev_prev_r...
%prev_row_in...%prev_row_in...%prev_row_in...%prev_row_in...%prev_row_in...
       %x.013.i       %x.013.i       %x.013.i       %x.013.i       %x.013.i
       %y.012.i       %y.012.i       %y.012.i       %y.012.i       %y.012.i
   %start.011.i   %start.011.i   %start.011.i   %start.011.i   %start.011.i
%y_offset.01...%y_offset.01...%y_offset.01...%y_offset.01...%y_offset.01...
%x_offset.09...%x_offset.09...%x_offset.09...%x_offset.09...%x_offset.09...
        %i.08.i        %i.08.i        %i.08.i        %i.08.i        %i.08.i
       <badref>       <badref>       <badref>       <badref>       <badref>
             %1             %1             %1             %1             %1
             %2             %2             %2             %2             %2
             %3             %3             %3             %3             %3
             %4             %4             %4             %4             %4
           %..i           %..i           %..i           %..i           %..i
              -             %5             %5             %5             %5
              -             %6             %6             %6             %6
             %7             %7             %7             %7             %7
             %8             %8             %8             %8             %8
             %9             %9             %9             %9             %9
            %10            %10            %10            %10            %10
              -       <badref>       <badref>       <badref>       <badref>
              -              -       <badref>       <badref>       <badref>
            %11            %11            %11            %11            %11
            %12            %12            %12            %12            %12
            %13            %13            %13            %13            %13
            %14            %14            %14            %14            %14
            %15            %15            %15            %15            %15
            %16            %16            %16            %16            %16
            %17            %17            %17            %17            %17
            %18            %18            %18            %18            %18
            %19            %19            %19            %19            %19
            %20            %20            %20            %20            %20
            %21            %21            %21            %21            %21
            %22            %22            %22            %22            %22
              -     %y.off.i.i     %y.off.i.i     %y.off.i.i     %y.off.i.i
              -    %phitmp.i.i    %phitmp.i.i    %phitmp.i.i    %phitmp.i.i
              -    %notlhs.i.i    %notlhs.i.i    %notlhs.i.i    %notlhs.i.i
              -    %notrhs.i.i    %notrhs.i.i    %notrhs.i.i    %notrhs.i.i
              -%not.or.cond...%not.or.cond...%not.or.cond...%not.or.cond...
              -   %phitmp..i.i   %phitmp..i.i   %phitmp..i.i   %phitmp..i.i
              -            %23            %23            %23            %23
            %24            %24            %24            %24            %24
            %25            %25            %25            %25            %25
            %26            %26            %26            %26            %26
            %27            %27            %27            %27            %27
              -            %28            %28            %28            %28
              -            %29            %29            %29            %29
              -            %30            %30            %30            %30
            %31            %31            %31            %31            %31
            %32            %32            %32            %32            %32
              -            %33            %33            %33            %33
              -            %34            %34            %34            %34
              -            %35            %35            %35            %35
              -            %36            %36            %36            %36
            %37            %37            %37            %37            %37
              -            %38            %38            %38            %38
              -              -            %39            %39            %39
              -            %40            %40            %40            %40
              -            %41            %41            %41            %41
              -            %42            %42            %42            %42
              -              -            %43            %43            %43
              -              -            %44            %44            %44
              -              -            %45            %45            %45
            %46            %46            %46            %46            %46
            %47            %47            %47            %47            %47
              -            %48            %48            %48            %48
              -              -            %49            %49            %49
              -              -            %50            %50            %50
              -              -              -            %51            %51
              -              -            %52            %52            %52
              -              -              -            %53            %53
              -              -              -            %54            %54
              -              -              -         %.op.i         %.op.i
              -              -              -    %..i1.neg.i    %..i1.neg.i
              -              -              -    %.op14.op.i    %.op14.op.i
              -              -              -              -        %.neg.i
              -              -              -              -            %55
              -            %56            %56            %56            %56
              -            %57            %57            %57            %57
              -              -              -              -            %58
              -              -              -              -            %59
              -            %60            %60            %60            %60
              -              -              -              -       <badref>
            %61            %61            %61            %61            %61
              -            %62            %62            %62            %62
              -            %63            %63            %63            %63
              -            %64            %64            %64            %64
              -            %65            %65            %65            %65
            %66            %66            %66            %66            %66
     %exitcond5     %exitcond5     %exitcond5     %exitcond5     %exitcond5
       <badref>       <badref>       <badref>       <badref>       <badref>

