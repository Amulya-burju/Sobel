//----------------------------------------------------------------------------//
// Generated by LegUp High-Level Synthesis Tool Version 4.0 (http://legup.org)
// Compiled: Sun Jul 26 12:56:54 2015
// University of Toronto
// For research and academic purposes only. Commercial use is prohibited.
// Please send bugs to: legup@eecg.toronto.edu
// Date: Sat Apr 20 05:40:15 2019
//----------------------------------------------------------------------------//

Found Loop: Loop at depth 2 containing: %59<header><latch><exiting>

Label: loop1
Trip count: 510
Induction variable:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ]
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Loop preheader: .preheader
--------------------------------------------------------------------------------

Calculating resource MII using IMS technique
Constraints from FuName: elaine_512_golden_output_local_mem_dual_port Issue Slots: 2
-  %62 = load i8* %scevgep, align 1, !tbaa !1
resMII (due to elaine_512_golden_output_local_mem_dual_port): 1
Constraints from FuName: main_0_sobel_output_local_mem_dual_port Issue Slots: 2
-  %61 = load i8* %scevgep4, align 1, !tbaa !1
resMII (due to main_0_sobel_output_local_mem_dual_port): 1
Overall resMII: 1
largestPossibleII: 15
resMII: 1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Finding all Loop Recurrences
Found 2 elementary recurrence cycles
Recurrence 1:
delay: 1 I:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
delay: 1 I:   %indvar.next = add i32 %indvar, 1
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Recurrence 2:
delay: 1 I:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
delay: 1 I:   %result.1. = add nsw i32 %63, %result.11
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Total cycle delay: 1
Total cycle dependency distance: 1
recMII = ceil(delay/distance) = 1

Overall recMII (max of recMII from all elementary recurrence cycles): 1
--------------------------------------------------------------------------------
Calculating recurrence MII using SDC scheduler
Trying recMII (SDC) = 1
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %result.1. = add nsw i32 %63, %result.11
	j:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %indvar.next = add i32 %indvar, 1
	j:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
recMII = 1 using SDC scheduler
--------------------------------------------------------------------------------
Initial II = 1
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %result.1. = add nsw i32 %63, %result.11
	j:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %indvar.next = add i32 %indvar, 1
	j:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Computing Heights
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.1..lcssa = phi i32 [ %result.1., %59 ]
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
No children (height=0):   tail call void @__legup_label(i8* getelementptr inbounds ([6 x i8]* @.str1, i32 0, i32 0)) #2
No children (height=0):   br i1 %exitcond1, label %64, label %59
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
--------------------------------------------------------------------------------
Height: 0:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Height: 0:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Height: 1:   %60 = add i32 %indvar, 1
Height: 1:   %scevgep4 = getelementptr [512 x [512 x i8]]* %sobel_output, i32 0, i32 %58, i32 %60
Height: 1:   %scevgep = getelementptr [512 x [512 x i8]]* @elaine_512_golden_output, i32 0, i32 %58, i32 %60
Height: 0:   tail call void @__legup_label(i8* getelementptr inbounds ([6 x i8]* @.str1, i32 0, i32 0)) #2
Height: 1:   %61 = load i8* %scevgep4, align 1, !tbaa !1
Height: 1:   %62 = load i8* %scevgep, align 1, !tbaa !1
Height: 0:   %not. = icmp ne i8 %61, %62
Height: 0:   %63 = zext i1 %not. to i32
Height: 0:   %result.1. = add nsw i32 %63, %result.11
Height: 0:   %indvar.next = add i32 %indvar, 1
Height: 0:   %exitcond1 = icmp eq i32 %indvar.next, 510
Height: 0:   br i1 %exitcond1, label %64, label %59
Modulo Scheduler Type: SDC_BACKTRACKING
--------------------------------------------------------------------------------
initializing SDC constraints for II = 1
distance 1 from:   %result.1. = add nsw i32 %63, %result.11 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %result.1. = add nsw i32 %63, %result.11
	j:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
distance 1 from:   %indvar.next = add i32 %indvar, 1 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Cross-iteration constraint: start of 'j' >= end of 'i' + chaining - II*distance(i, j)
	chaining: 0 II: 1 distance: 1
	i:   %indvar.next = add i32 %indvar, 1
	j:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
--------------------------------------------------------------------------------
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Finding initial ASAP schedule
Time: 1 I:   %61 = load i8* %scevgep4, align 1, !tbaa !1
Time: 1 I:   %62 = load i8* %scevgep, align 1, !tbaa !1
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Calculating perturbation priority function
Constraining >= 2.00:   %61 = load i8* %scevgep4, align 1, !tbaa !1
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 5 for:   %61 = load i8* %scevgep4, align 1, !tbaa !1
Constraining >= 2.00:   %62 = load i8* %scevgep, align 1, !tbaa !1
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Perturbation: 5 for:   %62 = load i8* %scevgep, align 1, !tbaa !1
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
--------------------------------------------------------------------------------
Control Step: 1
Scheduling:   %61 = load i8* %scevgep4, align 1, !tbaa !1
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 1?
No resource conflict: found available issue slot
Can we schedule instruction at time: 1 ignoring resource constraints?
Constraining == 1.00:   %61 = load i8* %scevgep4, align 1, !tbaa !1
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 1 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 1.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 1):   %61 = load i8* %scevgep4, align 1, !tbaa !1
TimeSlot: 1 Scheduling:   %61 = load i8* %scevgep4, align 1, !tbaa !1
Constraining == 1.00:   %61 = load i8* %scevgep4, align 1, !tbaa !1
Control Step: 1
Scheduling:   %62 = load i8* %scevgep, align 1, !tbaa !1
--------------------------------------------------------------------------------
Is there a conflict (resource or dependency) when scheduling at time slot: 1?
No resource conflict: found available issue slot
Can we schedule instruction at time: 1 ignoring resource constraints?
Constraining == 1.00:   %62 = load i8* %scevgep, align 1, !tbaa !1
  Solving SDC LP problem (modulo resource constraints are not modeled in the formulation)
  Found solution to SDC LP problem
Yes. Feasible to schedule instruction at time: 1 ignoring resource constraints.
No dependency conflict when scheduling at time slot: 1.
--------------------------------------------------------------------------------
Successfully scheduled (at time slot: 1):   %62 = load i8* %scevgep, align 1, !tbaa !1
TimeSlot: 1 Scheduling:   %62 = load i8* %scevgep, align 1, !tbaa !1
Constraining == 1.00:   %62 = load i8* %scevgep, align 1, !tbaa !1
Assigning timeslot: 0 to   %60 = add i32 %indvar, 1
Assigning timeslot: 2 to   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Assigning timeslot: 0 to   tail call void @__legup_label(i8* getelementptr inbounds ([6 x i8]* @.str1, i32 0, i32 0)) #2
Assigning timeslot: 2 to   %not. = icmp ne i8 %61, %62
Assigning timeslot: 2 to   %63 = zext i1 %not. to i32
Assigning timeslot: 3 to   %result.1. = add nsw i32 %63, %result.11
Assigning timeslot: 1 to   %scevgep4 = getelementptr [512 x [512 x i8]]* %sobel_output, i32 0, i32 %58, i32 %60
Assigning timeslot: 1 to   br i1 %exitcond1, label %64, label %59
Assigning timeslot: 0 to   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !4
Assigning timeslot: 0 to   %indvar.next = add i32 %indvar, 1
Assigning timeslot: 1 to   %exitcond1 = icmp eq i32 %indvar.next, 510
Assigning timeslot: 1 to   %scevgep = getelementptr [512 x [512 x i8]]* @elaine_512_golden_output, i32 0, i32 %58, i32 %60
Scheduled.
MII = 1
II = 1
Final Modulo Reservation Table:
FuName: elaine_512_golden_output_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   %62 = load i8* %scevgep, align 1, !tbaa !2
   issue slot: 1 instr: printing a <null> value
FuName: main_0_sobel_output_local_mem_dual_port
time slot: 0
   issue slot: 0 instr:   %61 = load i8* %scevgep4, align 1, !tbaa !2
   issue slot: 1 instr: printing a <null> value

Final Pipeline Schedule:
Total pipeline stages: 4
Stage: 0
Time: 0 Stage: 0 instr:   %indvar = phi i32 [ %indvar.next, %59 ], [ 0, %.preheader ], !legup.canonical_induction !5
Time: 0 Stage: 0 instr:   %60 = add i32 %indvar, 1
Time: 0 Stage: 0 instr:   tail call void @__legup_label(i8* getelementptr inbounds ([6 x i8]* @.str1, i32 0, i32 0)) #2
Time: 0 Stage: 0 instr:   %indvar.next = add i32 %indvar, 1
Stage: 1
Time: 1 Stage: 1 instr:   %scevgep4 = getelementptr [512 x [512 x i8]]* %sobel_output, i32 0, i32 %58, i32 %60
Time: 1 Stage: 1 instr:   %scevgep = getelementptr [512 x [512 x i8]]* @elaine_512_golden_output, i32 0, i32 %58, i32 %60
Time: 1 Stage: 1 instr:   %61 = load i8* %scevgep4, align 1, !tbaa !2
Time: 1 Stage: 1 instr:   %62 = load i8* %scevgep, align 1, !tbaa !2
Time: 1 Stage: 1 instr:   %exitcond1 = icmp eq i32 %indvar.next, 510
Time: 1 Stage: 1 instr:   br i1 %exitcond1, label %64, label %59
Stage: 2
Time: 2 Stage: 2 instr:   %result.11 = phi i32 [ %result.03, %.preheader ], [ %result.1., %59 ]
Time: 2 Stage: 2 instr:   %not. = icmp ne i8 %61, %62
Time: 2 Stage: 2 instr:   %63 = zext i1 %not. to i32
Stage: 3
Time: 3 Stage: 3 instr:   %result.1. = add nsw i32 %63, %result.11


Pipeline Table:
Total pipeline stages: 4
Stage:        0              1              2              3
   II:        0     |        0     |        0     |        0
 Time:        0     |        1     |        2     |        3
        %indvar        %indvar        %indvar        %indvar
              -              -     %result.11     %result.11
            %60            %60            %60            %60
              -      %scevgep4      %scevgep4      %scevgep4
              -       %scevgep       %scevgep       %scevgep
       <badref>       <badref>       <badref>       <badref>
              -            %61            %61            %61
              -            %62            %62            %62
              -              -          %not.          %not.
              -              -            %63            %63
              -              -              -     %result.1.
   %indvar.next   %indvar.next   %indvar.next   %indvar.next
              -     %exitcond1     %exitcond1     %exitcond1
              -       <badref>       <badref>       <badref>

